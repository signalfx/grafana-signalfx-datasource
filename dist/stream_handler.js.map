{"version":3,"sources":["../src/stream_handler.js"],"names":["defer","res","rej","promise","Promise","resolve","reject","_","TagProcessor","moment","MAX_DATAPOINTS_TO_KEEP_BEFORE_TIMERANGE","INACTIVE_JOB_MINUTES","STREAMING_THRESHOLD_MINUTES","StreamHandler","signalflow","templateSrv","tagProcessor","program","aliases","maxDelay","options","isJobReusable","unboundedBatchPhase","initializeTimeRange","flushData","stop","execute","setupCleanupTask","desiredMaxDelay","intervalMs","startTime","range","from","valueOf","unbounded","running","stopTime","to","jobStartTimeout","clearTimeout","setTimeout","console","debug","handle","close","log","initialize","params","start","resolution","stream","handleData","bind","metrics","maxDataPoints","resolutionMs","Date","now","cutoffTime","Math","min","err","data","message","type","messageCode","contents","maxDelayMs","event","appendData","batchPhaseFlushTimeout","i","length","point","datapoints","tsId","push","value","logicalTimestampMs","nextEstimatedTimestamp","ceil","floor","seriesList","minTime","maxTime","timeRangeStart","shift","tsName","timeSeriesNameAndId","get_metadata","properties","target","name","id","slice","sort","a","b","localeCompare"],"mappings":"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","file":"stream_handler.js","sourcesContent":["// Copyright (C) 2019-2020 Splunk, Inc. All rights reserved.\nimport _ from \"lodash\";\nimport { TagProcessor } from './tag_processor';\nimport moment from 'moment';\n\nfunction defer() {\n    let res, rej;\n\n    let promise = new Promise((resolve, reject) => {\n        res = resolve;\n        rej = reject;\n    });\n\n    promise.resolve = res;\n    promise.reject = rej;\n\n    return promise;\n}\n\nconst MAX_DATAPOINTS_TO_KEEP_BEFORE_TIMERANGE = 1;\nconst INACTIVE_JOB_MINUTES = 6;\nconst STREAMING_THRESHOLD_MINUTES = 2;\n\nexport class StreamHandler {\n\n    constructor(signalflow, templateSrv) {\n        this.signalflow = signalflow;\n        this.tagProcessor = new TagProcessor(templateSrv);\n    }\n\n    start(program, aliases, maxDelay, options) {\n        this.aliases = aliases;\n        if (this.isJobReusable(program, maxDelay, options)) {\n            if (!this.unboundedBatchPhase) {\n                this.promise = defer();\n                this.initializeTimeRange(options);\n                this.flushData();\n            }\n        } else {\n            this.promise = defer();\n            this.stop();\n            this.execute(program, maxDelay, options);\n        }\n        this.setupCleanupTask();\n        return this.promise;\n    }\n\n    isJobReusable(program, maxDelay, options) {\n        return this.program == program\n            && this.desiredMaxDelay == maxDelay\n            && this.intervalMs == options.intervalMs\n            && this.startTime <= options.range.from.valueOf()\n            && ((this.unbounded && this.running) || this.stopTime >= options.range.to.valueOf());\n    }\n\n    setupCleanupTask() {\n        if (this.jobStartTimeout) {\n            clearTimeout(this.jobStartTimeout);\n        }\n        this.jobStartTimeout = setTimeout(() => {\n            console.debug('Job inactive for ' + INACTIVE_JOB_MINUTES + ' minutes: ' + this.program);\n            this.stop();\n        }, INACTIVE_JOB_MINUTES * 60 * 1000);\n    }\n\n    stop() {\n        if (this.running) {\n            console.debug('Stopping SignalFlow computation.');\n            this.handle.close();\n            this.running = false;\n        }\n    }\n\n    execute(program, maxDelay, options) {\n        console.log('Starting SignalFlow computation: ' + program);\n        this.initialize(program, maxDelay, options);\n        const params = {\n            program: this.program,\n            start: this.startTime,\n            resolution: this.intervalMs,\n        };\n        if (!this.unbounded) {\n            params['stop'] = this.stopTime;\n            params['immediate'] = true;\n        }\n        if (this.maxDelay) {\n            params['maxDelay'] = this.maxDelay;\n        }\n        this.handle = this.signalflow.execute(params);\n        this.running = true;\n        this.handle.stream(this.handleData.bind(this));\n    }\n\n    initialize(program, maxDelay, options) {\n        this.metrics = {};\n        this.program = program;\n        this.maxDelay = maxDelay;\n        this.desiredMaxDelay = maxDelay;\n        this.initializeTimeRange(options);\n        this.intervalMs = options.intervalMs;\n        this.maxDataPoints = options.maxDataPoints;\n        this.resolutionMs = options.intervalMs;\n        this.unbounded = this.stopTime > Date.now() - STREAMING_THRESHOLD_MINUTES * 60 * 1000;\n        this.unboundedBatchPhase = this.unbounded;\n    }\n\n    initializeTimeRange(options) {\n        this.startTime = options.range.from.valueOf();\n        this.stopTime = options.range.to.valueOf();\n        this.cutoffTime = Math.min(Date.now(), this.stopTime);\n    }\n\n    handleData(err, data) {\n        if (err) {\n            console.debug('Stream error', err);\n            this.stop();\n            this.promise.reject(err.message);\n            return;\n        }\n\n        if (data.type === 'message' && data.message.messageCode === 'JOB_RUNNING_RESOLUTION') {\n            this.resolutionMs = data.message.contents.resolutionMs;\n        }\n\n        if (data.type === 'message' && data.message.messageCode === 'JOB_INITIAL_MAX_DELAY') {\n            this.maxDelay = data.message.contents.maxDelayMs;\n        }\n\n        if (data.type === 'control-message' && (data.event === 'END_OF_CHANNEL' || data.event === 'CHANNEL_ABORT')) {\n            this.flushData();\n            this.stop();\n        }\n\n        if (data.type !== 'data') {\n            console.debug(data);\n            return;\n        }\n\n        if (this.appendData(data) && this.unboundedBatchPhase) {\n            // Do not flush immediately as some more data may be still received\n            if (this.batchPhaseFlushTimeout) {\n                clearTimeout(this.batchPhaseFlushTimeout);\n            }\n            this.batchPhaseFlushTimeout = setTimeout(() => this.flushData(), 500);\n        }\n    }\n\n    appendData(data) {\n        for (let i = 0; i < data.data.length; i++) {\n            const point = data.data[i];\n            let datapoints = this.metrics[point.tsId];\n            if (!datapoints) {\n                datapoints = [];\n                this.metrics[point.tsId] = datapoints;\n            }\n            datapoints.push([point.value, data.logicalTimestampMs]);\n        }\n        // Estimate an align timestamps to boundaries based on resolution\n        const nextEstimatedTimestamp = data.logicalTimestampMs + Math.ceil(this.maxDelay / this.resolutionMs + 1) * this.resolutionMs;\n        return nextEstimatedTimestamp > Math.floor(this.cutoffTime / this.resolutionMs) * this.resolutionMs;\n    }\n\n    flushData() {\n        this.unboundedBatchPhase = false;\n        const seriesList = [];\n        let minTime = 0;\n        let maxTime = 0;\n        const timeRangeStart = this.startTime - MAX_DATAPOINTS_TO_KEEP_BEFORE_TIMERANGE * this.resolutionMs;\n        for (let tsId in this.metrics) {\n            const datapoints = this.metrics[tsId];\n            while (datapoints.length > 0 && timeRangeStart > datapoints[0][1]) {\n                datapoints.shift();\n            }\n            if (datapoints.length > 0) {\n                if (minTime == 0 || minTime > datapoints[0][1]) {\n                    minTime = datapoints[0][1];\n                }\n                if (maxTime == 0 || maxTime < datapoints[datapoints.length - 1][1]) {\n                    maxTime = datapoints[datapoints.length - 1][1];\n                }\n            }\n            const tsName = this.tagProcessor.timeSeriesNameAndId(tsId, this.handle.get_metadata(tsId).properties, this.aliases);\n            seriesList.push({ target: tsName.name, id: tsName.id, datapoints: datapoints.slice() });\n        }\n        // Ensure consistent TS order\n        seriesList.sort((a, b) => a.id.localeCompare(b.id));\n        const data = {\n            data: seriesList,\n            range: { from: moment(minTime), to: moment(maxTime) },\n        };\n        this.promise.resolve(data);\n        console.debug('Data returned: ' + this.program);\n    }\n\n}\n"]}